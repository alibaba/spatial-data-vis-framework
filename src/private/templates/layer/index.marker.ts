// $REMOVE_START$
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck

/**
 * @note @warn DO NOT EDIT THIS FILE. IT IS TEMPLATE CODE.
 */
// $REMOVE_END$

/**
 * $LAYER_NAME$
 */
import { Mesh } from '@gs.i/frontend-sdk'

import { StandardLayer, StandardLayerProps } from '@polaris.gl/gsi'

import type { PropDescription } from '../../private/schema/meta'
import {
	DescToParsedType,
	DescToType,
	DescToTypeMutable,
	parseProps,
} from '../../private/utils/props'

export const info = {
	name: '',
	description: '',
	category: 'Unknown',
}

/**
 * 详见 @see {@link [PropDescription](../../private/schema/meta.ts)}
 *
 * Props Description. Used to:
 * - generate default props.
 * - check props type and range.
 * - generate the props editor UI.
 */
export const propsDesc = [
	// example: mutable prop
	{
		key: 'lla',
		name: '经纬度海拔',
		type: 'vec3',
		defaultValue: { x: 120, y: 30, z: 0 },
		range: {
			min: { x: -180, y: -85, z: -10000 },
			max: { x: 180, y: 85, z: 1000000 },
		},
	},
	// example: immutable prop
	{
		key: 'image' as const,
		type: 'string' as const,
		defaultValue:
			'https://img.alicdn.com/imgextra/i1/O1CN01V6Tl3V1dzC8hdgJdi_!!6000000003806-2-tps-4096-4096.png',
		name: '你要绘制的图片链接',
		mutable: true,
	},
] as const

// @note type check. will be removed when compile.
propsDesc as readonly PropDescription[]

/**
 * $LAYER_NAME$ Props
 */
type $LAYER_NAME$Props = DescToType<typeof propsDesc>
type $LAYER_NAME$MutableProps = DescToTypeMutable<typeof propsDesc>

/**
 * factory function for $LAYER_NAME$
 *
 * @description 工厂函数模式说明
 *
 * @note 函数式编程
 * - propsDesc 中的所有属性，没有指明 mutable 的，默认都为 immutable
 * - immutable 属性变化，会销毁Layer，然后用全新的 props 重新执行工厂函数
 * - 工厂函数无状态，但是可以通过闭包自行缓存一些计算
 *
 * @legacy 兼容经典的监听模式
 * - 如果希望某个属性可以运行时频繁变化
 * - - propsDesc 中将其标为 `mutable: true`
 * - - 通过 `layer.watchProps()` / `layer.watchProp()` 监听变化并响应
 */
export function create$LAYER_NAME$(props: $LAYER_NAME$Props) {
	console.log('create$LAYER_NAME$')

	// 补全缺省值，并检查必要性、类型和值范围
	const parsedProps = parseProps(props, propsDesc)

	const layer = new StandardLayer<StandardLayerProps & $LAYER_NAME$MutableProps>({
		name: '$LAYER_NAME$',
		...parsedProps,
	})

	layer.addEventListener('init', async (e) => {
		const { projection, timeline, polaris } = e

		// 你要绘制的2D元素
		const img = document.createElement('img')
		img.src = parsedProps.image
		img.style.width = '100px'

		// 控制地理定位的wrapper
		const geoWrapper = document.createElement('div')
		geoWrapper.appendChild(img)
		geoWrapper.style.position = 'absolute'
		geoWrapper.style.left = '0'
		geoWrapper.style.top = '0'

		// 加入视图
		layer.element.appendChild(geoWrapper)
		layer.element.style.position = 'relative'

		// 定位锚，这里以 GSI 为例，three js 的用法相似
		const anchor = new Mesh()
		const lla = parsedProps.lla
		const pos = projection.project(lla.x, lla.y, lla.z)
		anchor.transform.position.set(pos[0], pos[1], pos[2])
		layer.group.add(anchor)

		// 获取锚的屏幕位置，并更新 geoWrapper 元素
		const updateHtmlPos = () => {
			// GSI 中这样获取屏幕空间位置
			const matPro = e.polaris['matrixProcessor']
			const worldMatrix = matPro.getWorldMatrix(anchor)
			const worldPos = { x: worldMatrix[12], y: worldMatrix[13], z: worldMatrix[14] }
			const screenPos = e.polaris.getScreenXY(worldPos.x, worldPos.y, worldPos.z)!

			// ✨
			geoWrapper.style.transform = `translate(${screenPos[0]}px, ${
				e.polaris.height - screenPos[1]
			}px)`
		}

		// 监听视图变化，自动更新
		layer.addEventListener('viewChange', (e) => {
			updateHtmlPos()
		})

		layer.useProp('image', (image) => {
			img.src = image
		})
	})

	return layer
}
