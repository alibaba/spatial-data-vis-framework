/* eslint-disable no-unused-labels */

/**
 * @file PolarisApp
 * @description
 * Polaris App 的标准应用
 * @note
 * 不要修改该类，如果要增加自定义接口或参数，再该文件夹中创建一个新的类，继承或包裹该标准应用
 * **DO NOT EDIT THIS FILE**
 */
import { createFromDesc } from '@polaris.gl/projection'

import { LayerClasses } from '../layers'
import { AppBase } from '../private/base/AppBase'
import { SceneBase } from '../private/base/SceneBase'
import { ScriptBase } from '../private/base/ScriptBase'
import { StageBase } from '../private/base/StageBase'
import { ConfigManager } from '../private/config/ConfigManager'
import type { AppConfig, DataStub, LayerConfig } from '../private/schema/config'
import type { AppMeta, LayerClassesShape } from '../private/schema/meta'
import { getErrorMask } from '../private/utils/getErrorMask'
import { partialFreeze } from '../private/utils/partialFreeze'
import { freeID, occupyID } from '../private/utils/unique'

const SCOPE_KEY = Symbol('scopeKey')

/**
 * Entry Class. 入口应用
 *
 * @usage
 * ```typescript
 * import { App } from './app.mjs'
 *
 * const container = document.getElementById('container')
 * const DefaultConfig = await (await fetch('./config.json')).json()
 *
 * const polarisApp = new App(container, DefaultConfig)
 * ```
 *
 * @todo 在这里可以把类型静态化
 */
export class App extends AppBase {
	readonly configManager = new ConfigManager<typeof LayerClasses>()

	private readonly scripts: ScriptBase[]

	private readonly [SCOPE_KEY] = {}

	constructor(container: HTMLDivElement, config: AppConfig<typeof LayerClasses>) {
		const scope = {} // 用于检查是否有重复的 ID
		// create layers
		const layers = config.layers.map((layer) => {
			// 如果 有 dataProps 而且对应的 dataStub 有初始值，则创建的时候直接带上初始值

			const initialProps = getInitialProps(layer, config.dataStubs)

			return {
				layer: createLayer(LayerClasses, layer.class, initialProps, layer),
				name: layer.name,
				id: occupyID(scope, layer.id),
			}
		})

		// create stages (layer containers)
		const stages = config.stages.map((stage) => {
			return new StageBase({
				projection: stage.projection ? createFromDesc(stage.projection) : undefined,
				layers: layers.filter((l) => stage.layers.includes('*') || stage.layers.includes(l.id)),
				name: stage.name,
				id: stage.id,
			})
		})

		// create scenes (layer filters and camera states)
		const scenes = config.scenes.map((scene) => {
			const s = new SceneBase()
			s.id = occupyID(scope, scene.id)
			s.name = scene.name
			s.cameraStateCode = scene.cameraStateCode
			s.layers = scene.layers ?? ['*']

			return s
		})

		super(container, config, stages, scenes, layers)

		this[SCOPE_KEY] = scope

		// scripts
		const scriptsConfig = config.$scripts ?? []
		this.scripts = scriptsConfig.map((scriptConfig) => {
			return new ScriptBase(this, scriptConfig)
		})
		this.addEventListener('dispose', () => this.scripts.forEach((s) => s.dispose()))

		if (config.app.debug) {
			// safe check. throw if config not immutable
			this.configManager.useDeepFreeze = true
		}

		this.configManager.init(config)

		this.watchConfig()

		// event
		this.dispatchEvent(Object.freeze({ type: 'afterInit', target: this }))

		ViteHot: if (import.meta.hot) {
			// @note 仅在开发环境下启用热更新, label 用于让 rollup 删除这段代码
			handleViteHot(container)
		}
	}

	/**
	 * listen to config change
	 */
	private watchConfig() {
		const m = this.configManager
		m.addEventListener('app:change', (e) => {
			this.polaris.setProps(e.data)
		})

		m.addEventListener('layer:add', (e) => {
			const initialProps = getInitialProps(e.data, m.getConfig().dataStubs)
			const layer = createLayer(LayerClasses, e.data.class, initialProps, e.data)
			this.layers.push({ layer, name: e.data.name, id: occupyID(this[SCOPE_KEY], e.data.id, true) })

			// @note 目前仅支持 default stage
			const defaultStage = this.stages.find((s) => s.id === 'LOCAL_STAGE_MAIN')
			if (!defaultStage) throw new Error('default stage not found')
			defaultStage.addLayer(e.data.id, layer)
			this.updateLayerFilters()
		})

		m.addEventListener('layer:remove', (e) => {
			const id = e.data.id
			freeID(this[SCOPE_KEY], id)
			const index = this.layers.findIndex((l) => l.id === id)
			if (index >= 0) {
				const layer = this.layers[index].layer
				// @todo 注意，未来允许多个 Stage 后，这里会出现 parent 为 null 的情况
				const stage = layer.parent as StageBase
				stage.removeLayer(id)
				layer.dispose()
				this.layers.splice(index, 1)
			}
			this.updateLayerFilters()
		})

		m.addEventListener('layer:change:name', (e) => {
			const layer = this.layers.find((l) => l.id === e.data.id)
			if (layer) layer.name = e.data.name
		})

		m.addEventListener('layer:change:props', (e) => {
			const layer = this.layers.find((l) => l.id === e.data.id)
			const changedKeys = e.data.changedKeys

			// 区分 可变 与 不可变的 props

			const layerConfig = this.getLayerConfigById(e.data.id)

			if (!layerConfig) throw new Error('layer config not found')

			const layerClassName = layerConfig.class

			if (changedKeys && layerShouldRecreate(LayerClasses, layerClassName, changedKeys)) {
				this.recreateLayer(e.data.id, 'layer:change:props')
			} else {
				if (layer) layer.layer.setProps(e.data.props)
			}
		})

		m.addEventListener('layer:change:dataProps', (e) => {
			// recreate layer
			this.recreateLayer(e.data.id, 'layer:change:dataProps')
		})

		m.addEventListener('stage:add', (e) => {
			throw new Error('not implemented')
			// const stage = new StageBase({
			// 	projection: e.data.projection ? createFromDesc(e.data.projection) : undefined,
			// 	layers: this.layers.filter((l) => e.data.layers.includes(l.id)),
			// 	name: e.data.name,
			// 	id: e.data.id,
			// })

			// this.stages.push(stage)
		})

		m.addEventListener('stage:remove', (e) => {
			throw new Error('not implemented')
			// const index = this.stages.findIndex((s) => s.id === e.data.id)
			// if (index >= 0) {
			// 	const stage = this.stages[index]
			// 	stage.dispose()
			// 	this.stages.splice(index, 1)
			// }
		})

		m.addEventListener('stage:change:name', (e) => {
			const stage = this.stages.find((s) => s.id === e.data.id)
			if (stage) stage.name = e.data.name
		})

		m.addEventListener('stage:change:projection', (e) => {
			throw new Error('not implemented')
		})

		m.addEventListener('stage:change:layers', (e) => {
			this.updateLayerFilters()
		})

		m.addEventListener('scene:add', (e) => {
			const scene = new SceneBase()
			scene.id = occupyID(this[SCOPE_KEY], e.data.id, true)
			scene.name = e.data.name
			scene.cameraStateCode = e.data.cameraStateCode
			scene.layers = e.data.layers ?? ['*']

			this.scenes.push(scene)
		})

		m.addEventListener('scene:remove', (e) => {
			if (e.data.id === 'LOCAL_SCENE_DEFAULT') {
				throw new Error('cannot remove default scene')
			}

			freeID(this[SCOPE_KEY], e.data.id)

			const index = this.scenes.findIndex((s) => s.id === e.data.id)
			if (index >= 0) {
				// const scene = this.scenes[index]
				this.scenes.splice(index, 1)
			}
		})

		m.addEventListener('scene:change:name', (e) => {
			const scene = this.scenes.find((s) => s.id === e.data.id)
			if (scene) scene.name = e.data.name
		})

		m.addEventListener('scene:change:cameraStateCode', (e) => {
			const scene = this.scenes.find((s) => s.id === e.data.id)
			if (!scene) throw new Error('scene not found')

			scene.cameraStateCode = e.data.cameraStateCode

			// 如果处于这个scene，则立即生效
			if (this.currentSceneID === scene.id) {
				this.changeScene(scene.id)
			}
		})

		m.addEventListener('scene:change:layers', (e) => {
			const scene = this.scenes.find((s) => s.id === e.data.id)

			if (!scene) throw new Error('scene not found')

			scene.layers = e.data.layers

			// 如果处于这个scene，则立即生效
			if (this.currentSceneID === scene.id) {
				// 这里不改变相机机位（skipCamera）
				this.changeScene(scene.id, 0, true)
			}
		})

		// add new data stub
		// 无需处理，由 layer:change:dataProps 处理

		// remove data stub
		m.addEventListener('data:remove', (e) => {
			const config = this.configManager.getConfig()
			// 找到所有使用了这个 dataStub 的 layer
			const ids = findLayerIDsRelatedToDataStub(config.layers, e.data.id)
			const layers = this.layers.filter((l) => ids.includes(l.id))
			// throw or warn
			layers.forEach((l) => {
				const err = new Error(`layer ${l.id} is using a removed data stub ${e.data.id}`)
				// console.error(err)
				throw err
			})
		})

		// change data stub initialValue
		m.addEventListener('data:change:initialValue', (e) => {
			// 找到所有使用了这个 dataStub 的 layer
			const config = this.configManager.getConfig()
			const ids = findLayerIDsRelatedToDataStub(config.layers, e.data.id)
			// recreate related layers
			ids.forEach((id) => {
				this.recreateLayer(id, 'data:change:initialValue')
			})
		})

		// scripts

		m.addEventListener('script:add', (e) => {
			this.scripts.push(new ScriptBase(this, e.data))
		})

		m.addEventListener('script:remove', (e) => {
			const index = this.scripts.findIndex((s) => s.id === e.data.id)
			if (index >= 0) {
				const script = this.scripts[index]
				this.scripts.splice(index, 1)
				script.dispose()
			} else {
				throw new Error('script not found')
			}
		})

		m.addEventListener('script:change:name', (e) => {
			const script = this.scripts.find((s) => s.id === e.data.id)
			if (script) script.changeName(e.data.name)
		})

		m.addEventListener('script:change:handler', (e) => {
			const script = this.scripts.find((s) => s.id === e.data.id)
			if (script) script.changeHandler(e.data.handler)
		})

		m.addEventListener('script:change:eventType', (e) => {
			const script = this.scripts.find((s) => s.id === e.data.id)
			if (script) script.changeEventType(e.data.eventType)
		})

		m.addEventListener('script:change:targets', (e) => {
			const script = this.scripts.find((s) => s.id === e.data.id)
			if (script) script.changeTargets(e.data.targets)
		})
	}

	/**
	 * re-filter layers in stages and scenes
	 * @todo 未来允许多Stage后，当心一个layer被多个stage包含，应该从 layers 开始遍历，而非从 stages 开始
	 */
	private updateLayerFilters() {
		const config = this.configManager.getConfig()
		for (const stage of this.stages) {
			const stageConfig = config.stages.find((s) => s.id === stage.id)

			if (!stageConfig) throw new Error('stage exist but not found in config')

			const currLayers = stage.getLayerList()
			const nextLayers = this.layers.filter(
				(l) => stageConfig.layers.includes('*') || stageConfig.layers.includes(l.id)
			)

			const currentLayerIDs = currLayers.map((l) => l.id)
			const nextLayerIDs = nextLayers.map((l) => l.id)

			// find added and removed layers
			const addedLayers = nextLayers.filter((l) => !currentLayerIDs.includes(l.id))
			const removedLayers = currLayers.filter((l) => !nextLayerIDs.includes(l.id))

			for (const layer of removedLayers) {
				stage.removeLayer(layer.id)
			}

			for (const layer of addedLayers) {
				stage.addLayer(layer.id, layer.layer, layer.name)
			}
		}
	}

	/**
	 * 更新一个 data stub 的 value
	 * @experimental
	 */
	updateDataStub(id: string, value: any) {
		const config = this.configManager.getConfig()
		const stub = config.dataStubs?.find((s) => s.id === id)

		if (!stub) throw new Error(`data stub (id: ${id}) not found.`)

		// event: beforeUpdateData
		// 该事件允许在更新 data stub 之前，对 value 进行校验和修改
		// 相当于 DataStub 粒度的数据过滤器
		// 注意，如果有多个回调，所修改的是同一份数据，该事件的影响并不区分currentTarget
		const event = partialFreeze(
			{ type: 'beforeUpdateData' as const, target: this, dataStubID: id, value },
			['type', 'target', 'dataStubID']
		)
		this.dispatchEvent(event)

		const newValue = event.value

		// @todo dynamic limit

		// @todo @perf cache this
		const affectedLayers = config.layers.filter(
			(l) => l.dataProps && Object.values(l.dataProps).includes(id)
		)

		for (const layerConfig of affectedLayers) {
			// @note 直接调用 setProps，config 是静态的，data updating should not touch config

			const layerInstance = this.layers.find((l) => l.id === layerConfig.id)

			if (!layerInstance) throw new Error(`layer (id: ${layerConfig.id}) not found.`)

			const affectedProps = {} as Record<string, any>
			const affectedPropsKeys = [] as string[]
			// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
			Object.entries(layerConfig.dataProps!).forEach(([propKey, dataStubID]) => {
				if (dataStubID === id) {
					affectedProps[propKey] = newValue
					affectedPropsKeys.push(propKey)
				}
			})

			if (layerShouldRecreate(LayerClasses, layerConfig.class, affectedPropsKeys)) {
				this.recreateLayer(layerConfig.id, 'updateDataStub')
			} else {
				layerInstance.layer.setProps(affectedProps)
			}
		}
	}

	private recreateLayer(id: string, cause?: string) {
		const config = this.configManager.getConfig()
		const layerConfig = config.layers.find((l) => l.id === id)

		if (!layerConfig) throw new Error(`layer (id: ${id}) not found.`)

		console.log(
			`%cPolarisApp: recreating layer(${id},${layerConfig.name})`,
			'background: #222; color: #ffff33'
		)
		if (cause) console.log(' \\_caused by', cause)

		// create a new instance of this layer
		const initialProps = getInitialProps(layerConfig, config.dataStubs)
		const newLayerInstance = createLayer(LayerClasses, layerConfig.class, initialProps, layerConfig)

		// replace the old one
		const layer = this.layers.find((l) => l.id === layerConfig.id)
		if (!layer) throw new Error('layer not found')

		this.mainStage.removeLayer(layer.id)
		layer.layer.dispose() // NOTE: this is usually empty, but some layers may have custom dispose logic

		layer.layer = newLayerInstance
		this.mainStage.addLayer(layer.id, newLayerInstance, layer.name)

		// refilter to make sure new layers follow the scene filter
		const currentSceneConfig = config.scenes.find((s) => s.id === this.currentSceneID)
		if (!currentSceneConfig) {
			throw new Error(`scene (id: ${this.currentSceneID}) not found.`)
		}
		this.mainStage.filterLayers(currentSceneConfig.layers)
	}

	/**
	 * dispose polaris and all layers and re-create them
	 * - used when config has breaking changes
	 */
	private recreatePolaris() {
		// @todo
	}
	private recreateStage() {
		// seems useless. just recreate related layers.
	}

	private getLayerConfigById(id: string) {
		const config = this.configManager.getConfig()
		return config.layers.find((l) => l.id === id)
	}

	static $getMeta(): AppMeta {
		return {
			layers: { ...LayerClasses },
		}
	}
}

/**
 * Create a layer instance by class name and constructor props
 */
function createLayer<
	TLayerClasses extends LayerClassesShape,
	TClassName extends keyof TLayerClasses
>(
	classes: TLayerClasses,
	className: TClassName,
	props: Parameters<TLayerClasses[TClassName]['factory']>[0],
	config: LayerConfig
): ReturnType<TLayerClasses[TClassName]['factory']> {
	const factory = classes[className]?.factory as TLayerClasses[TClassName]['factory']
	if (!factory) throw new Error(`Cannot find layer type: ${String(className)}.`)

	const namedProps = { name: config.name, ...props } as any
	const instance = factory(namedProps) as ReturnType<TLayerClasses[TClassName]['factory']>

	return instance
}

function findLayerIDsRelatedToDataStub(layersConfig: LayerConfig[], id: string) {
	return layersConfig
		.filter((l) => l.dataProps && Object.values(l.dataProps).includes(id))
		.map((l) => l.id)
}

function getInitialProps(layerConfig: LayerConfig, dataStubs?: DataStub[]) {
	const initialProps = { ...layerConfig.props }

	if (layerConfig.dataProps) {
		Object.entries(layerConfig.dataProps).forEach(([propKey, dataStubID]) => {
			const dataStub = dataStubs?.find((stub) => stub.id === dataStubID)

			if (!dataStub)
				throw new Error(`dataStub (${dataStubID}) required by layer (${layerConfig.id}) not found.`)

			if (initialProps[propKey] !== undefined)
				throw new Error(`prop and dataProp can't have the same key (${propKey}).`)

			if (dataStub.initialValue !== undefined) {
				initialProps[propKey] = dataStub.initialValue
			}
		})
	}

	return initialProps
}

function layerShouldRecreate<
	TLayerClasses extends LayerClassesShape,
	TClassName extends keyof TLayerClasses
>(classes: TLayerClasses, className: TClassName, changedKeys: string[]): boolean {
	const layerClass = classes[className]
	if (!layerClass) throw new Error(`Cannot find layer type:  ${String(className)}.`)

	const { propsDescription } = layerClass

	const immutableKeys = propsDescription.filter((p) => !p.mutable).map((p) => p.key)

	return changedKeys.some((key) => immutableKeys.includes(key))
}

//

function handleViteHot(container: HTMLDivElement) {
	ViteHot: if (import.meta.hot) {
		// @note 仅在开发环境下启用热更新, label 用于让 rollup 删除这段代码

		// 用于显示错误信息的mask
		const { errorMask, errorMaskText } = getErrorMask()
		container.appendChild(errorMask)

		// 处理bug
		import.meta.hot.on('vite:error', (e) => {
			console.error('vite syntax error', e)
		})

		// 处理自身更新
		import.meta.hot.accept((newModule) => {
			if (newModule) {
				errorMask.style.display = 'none'

				// newModule is undefined when SyntaxError happened
				const reloadAppMod = globalThis.__Polaris_Dev_Reload_App_Module

				if (reloadAppMod) {
					console.log('received newModule. will call reloadAppMod.')
					reloadAppMod(newModule)
				} else {
					console.warn('refreshApp not found. should reload page.')
					location.reload()
				}
			} else {
				errorMask.style.display = 'flex'
				errorMaskText.innerText = 'SyntaxError. Check console for details.'
			}
		})

		// 处理 layer 更新
		// import.meta.hot.accept('../layers/index.ts', (newModule) => {
		// 	console.log('updated: layers', newModule)
		// 	if (newModule) {
		// 		const newLayerClasses = newModule.LayerClasses
		// 		// find whats changed
		// 		const changed = Object.keys(LayerClasses).filter((key) => {
		// 			return LayerClasses[key] !== newLayerClasses[key]
		// 		})
		// 		console.log('changed', changed)
		// 	}
		// 	// @todo 重新创建 layers
		// })
	}
}
