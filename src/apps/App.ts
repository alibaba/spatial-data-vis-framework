/* eslint-disable no-unused-labels */

/**
 * @file PolarisApp
 * @description
 * Polaris App 的标准应用
 * @note
 * 不要修改该类，如果要增加自定义接口或参数，再该文件夹中创建一个新的类，继承或包裹该标准应用
 * **DO NOT EDIT THIS FILE**
 */
import type { StandardLayer } from '@polaris.gl/gsi'
import { createFromDesc } from '@polaris.gl/projection'

import { LayerClasses } from '../layers'
import { AppBase } from '../private/base/AppBase'
import { SceneBase } from '../private/base/SceneBase'
import { StageBase } from '../private/base/StageBase'
import { ConfigManager } from '../private/config/ConfigManager'
import type { AppConfig, DataStub, LayerConfig } from '../private/schema/config'
import type { AppMeta, LayerClassesShape } from '../private/schema/meta'
import { freeID, occupyID } from '../private/utils/unique'

const SCOPE_KEY = Symbol('scopeKey')

/**
 * Entry Class. 入口应用
 *
 * @usage
 * ```typescript
 * import { App } from './app.mjs'
 *
 * const container = document.getElementById('container')
 * const DefaultConfig = await (await fetch('./config.json')).json()
 *
 * const polarisApp = new App(container, DefaultConfig)
 * ```
 *
 * @todo 在这里可以把类型静态化
 */
export class App extends AppBase {
	readonly configManager = new ConfigManager<typeof LayerClasses>()
	readonly layers = [] as { layer: StandardLayer; name: string; id: string }[]

	private readonly [SCOPE_KEY] = {}

	constructor(container: HTMLDivElement, config: AppConfig<typeof LayerClasses>) {
		const scope = {} // 用于检查是否有重复的 ID
		// create layers
		const layers = config.layers.map((layer) => {
			// 如果 有 dataProps 而且对应的 dataStub 有初始值，则创建的时候直接带上初始值

			const initialProps = getInitialProps(layer, config.dataStubs)

			return {
				layer: createLayer(LayerClasses, layer.class, initialProps),
				name: layer.name,
				id: occupyID(scope, layer.id),
			}
		})

		// create stages (layer containers)
		const stages = config.stages.map((stage) => {
			return new StageBase({
				projection: stage.projection ? createFromDesc(stage.projection) : undefined,
				layers: layers.filter((l) => stage.layers.includes('*') || stage.layers.includes(l.id)),
				name: stage.name,
				id: stage.id,
			})
		})

		// create scenes (layer filters and camera states)
		const scenes = config.scenes.map((scene) => {
			const s = new SceneBase()
			s.id = occupyID(scope, scene.id)
			s.name = scene.name
			s.cameraStateCode = scene.cameraStateCode
			s.layers = scene.layers ?? ['*']

			return s
		})

		//
		super(container, config, stages, scenes)

		this[SCOPE_KEY] = scope

		this.layers = layers

		this.configManager.init(config)

		this.watchConfig()

		ViteHot: if (import.meta.hot) {
			// @note 仅在开发环境下启用热更新, label 用于让 rollup 删除这段代码

			// 处理自身更新
			import.meta.hot.accept((newModule) => {
				if (newModule) {
					// newModule is undefined when SyntaxError happened
					const reloadAppMod = globalThis.__Polaris_Dev_Reload_App_Module

					if (reloadAppMod) {
						console.log('received newModule. will call reloadAppMod.')
						reloadAppMod(newModule)
					} else {
						console.warn('refreshApp not found. should reload page.')
						location.reload()
					}
				} else {
					console.warn('newModule is undefined. Check SyntaxErrors in your code.')
					// location.reload()
				}
			})

			// 处理 layer 更新
			// import.meta.hot.accept('../layers/index.ts', (newModule) => {
			// 	console.log('updated: layers', newModule)
			// 	if (newModule) {
			// 		const newLayerClasses = newModule.LayerClasses
			// 		// find whats changed
			// 		const changed = Object.keys(LayerClasses).filter((key) => {
			// 			return LayerClasses[key] !== newLayerClasses[key]
			// 		})
			// 		console.log('changed', changed)
			// 	}
			// 	// @todo 重新创建 layers
			// })
		}
	}

	/**
	 * listen to config change
	 */
	private watchConfig() {
		const m = this.configManager
		m.addEventListener('app:change', (e) => {
			this.polaris.setProps(e.data)
		})

		m.addEventListener('layer:add', (e) => {
			const initialProps = getInitialProps(e.data, m.getConfig().dataStubs)
			const layer = createLayer(LayerClasses, e.data.class, initialProps)
			this.layers.push({ layer, name: e.data.name, id: occupyID(this[SCOPE_KEY], e.data.id, true) })

			// @note 目前仅支持 default stage
			const defaultStage = this.stages.find((s) => s.id === 'LOCAL_STAGE_MAIN')
			if (!defaultStage) throw new Error('default stage not found')
			defaultStage.addLayer(e.data.id, layer)
			this.updateLayerFilters()
		})

		m.addEventListener('layer:remove', (e) => {
			const id = e.data.id
			freeID(this[SCOPE_KEY], id)
			const index = this.layers.findIndex((l) => l.id === id)
			if (index >= 0) {
				const layer = this.layers[index].layer
				// @todo 注意，未来允许多个 Stage 后，这里会出现 parent 为 null 的情况
				const stage = layer.parent as StageBase
				stage.removeLayer(id)
				layer.dispose()
				this.layers.splice(index, 1)
			}
			this.updateLayerFilters()
		})

		m.addEventListener('layer:change:name', (e) => {
			const layer = this.layers.find((l) => l.id === e.data.id)
			if (layer) layer.name = e.data.name
		})

		m.addEventListener('layer:change:props', (e) => {
			const layer = this.layers.find((l) => l.id === e.data.id)
			const changedKeys = e.data.changedKeys

			// 区分 可变 与 不可变的 props

			const layerConfig = this.getLayerConfigById(e.data.id)

			if (!layerConfig) throw new Error('layer config not found')

			const layerClassName = layerConfig.class

			if (changedKeys && layerShouldRecreate(LayerClasses, layerClassName, changedKeys)) {
				this.recreateLayer(e.data.id)
			} else {
				if (layer) layer.layer.setProps(e.data.props)
			}
		})

		m.addEventListener('layer:change:dataProps', (e) => {
			// recreate layer
			this.recreateLayer(e.data.id)
		})

		m.addEventListener('stage:add', (e) => {
			throw new Error('not implemented')
			// const stage = new StageBase({
			// 	projection: e.data.projection ? createFromDesc(e.data.projection) : undefined,
			// 	layers: this.layers.filter((l) => e.data.layers.includes(l.id)),
			// 	name: e.data.name,
			// 	id: e.data.id,
			// })

			// this.stages.push(stage)
		})

		m.addEventListener('stage:remove', (e) => {
			throw new Error('not implemented')
			// const index = this.stages.findIndex((s) => s.id === e.data.id)
			// if (index >= 0) {
			// 	const stage = this.stages[index]
			// 	stage.dispose()
			// 	this.stages.splice(index, 1)
			// }
		})

		m.addEventListener('stage:change:name', (e) => {
			const stage = this.stages.find((s) => s.id === e.data.id)
			if (stage) stage.name = e.data.name
		})

		m.addEventListener('stage:change:projection', (e) => {
			throw new Error('not implemented')
		})

		m.addEventListener('stage:change:layers', (e) => {
			this.updateLayerFilters()
		})

		m.addEventListener('scene:add', (e) => {
			const scene = new SceneBase()
			scene.id = occupyID(this[SCOPE_KEY], e.data.id, true)
			scene.name = e.data.name
			scene.cameraStateCode = e.data.cameraStateCode
			scene.layers = e.data.layers ?? ['*']

			this.scenes.push(scene)
		})

		m.addEventListener('scene:remove', (e) => {
			if (e.data.id === 'LOCAL_SCENE_DEFAULT') {
				throw new Error('cannot remove default scene')
			}

			freeID(this[SCOPE_KEY], e.data.id)

			const index = this.scenes.findIndex((s) => s.id === e.data.id)
			if (index >= 0) {
				// const scene = this.scenes[index]
				this.scenes.splice(index, 1)
			}
		})

		m.addEventListener('scene:change:name', (e) => {
			const scene = this.scenes.find((s) => s.id === e.data.id)
			if (scene) scene.name = e.data.name
		})

		m.addEventListener('scene:change:cameraStateCode', (e) => {
			const scene = this.scenes.find((s) => s.id === e.data.id)
			if (!scene) throw new Error('scene not found')

			scene.cameraStateCode = e.data.cameraStateCode

			// 如果处于这个scene，则立即生效
			if (this.currentSceneID === scene.id) {
				this.changeScene(scene.id)
			}
		})

		m.addEventListener('scene:change:layers', (e) => {
			const scene = this.scenes.find((s) => s.id === e.data.id)

			if (!scene) throw new Error('scene not found')

			scene.layers = e.data.layers

			// 如果处于这个scene，则立即生效
			if (this.currentSceneID === scene.id) {
				this.changeScene(scene.id)
			}
		})

		// add new data stub
		// 由于 不允许 layer 使用不存在的 dataStub, 所以这里不需要处理

		// remove data stub
		m.addEventListener('data:remove', (e) => {
			const config = this.configManager.getConfig()
			// 找到所有使用了这个 dataStub 的 layer
			const ids = findLayerIDsRelatedToDataStub(config.layers, e.data.id)
			const layers = this.layers.filter((l) => ids.includes(l.id))
			// throw or warn
			layers.forEach((l) => {
				const err = new Error(`layer ${l.id} is using a removed data stub ${e.data.id}`)
				// console.error(err)
				throw err
			})
		})

		// change data stub initialValue
		m.addEventListener('data:change:initialValue', (e) => {
			// 找到所有使用了这个 dataStub 的 layer
			const config = this.configManager.getConfig()
			const ids = findLayerIDsRelatedToDataStub(config.layers, e.data.id)
			// recreate related layers
			ids.forEach((id) => {
				this.recreateLayer(id)
			})
		})
	}

	/**
	 * re-filter layers in stages and scenes
	 * @todo 未来允许多Stage后，当心一个layer被多个stage包含，应该从 layers 开始遍历，而非从 stages 开始
	 */
	private updateLayerFilters() {
		const config = this.configManager.getConfig()
		for (const stage of this.stages) {
			const stageConfig = config.stages.find((s) => s.id === stage.id)

			if (!stageConfig) throw new Error('stage exist but not found in config')

			const currLayers = stage.getLayerList()
			const nextLayers = this.layers.filter(
				(l) => stageConfig.layers.includes('*') || stageConfig.layers.includes(l.id)
			)

			const currentLayerIDs = currLayers.map((l) => l.id)
			const nextLayerIDs = nextLayers.map((l) => l.id)

			// find added and removed layers
			const addedLayers = nextLayers.filter((l) => !currentLayerIDs.includes(l.id))
			const removedLayers = currLayers.filter((l) => !nextLayerIDs.includes(l.id))

			for (const layer of removedLayers) {
				stage.removeLayer(layer.id)
			}

			for (const layer of addedLayers) {
				stage.addLayer(layer.id, layer.layer, layer.name)
			}
		}
	}

	/**
	 * 更新一个 data stub 的 value
	 * @experimental
	 */
	updateDataStub(id: string, value: any) {
		const config = this.configManager.getConfig()
		const stub = config.dataStubs?.find((s) => s.id === id)

		if (!stub) throw new Error(`data stub (id: ${id}) not found.`)

		// @todo dynamic limit

		// @todo @perf cache this
		const affectedLayers = config.layers.filter(
			(l) => l.dataProps && Object.values(l.dataProps).includes(id)
		)

		for (const layerConfig of affectedLayers) {
			// @note 直接调用 setProps，config 是静态的，data updating should not touch config

			const layerInstance = this.layers.find((l) => l.id === layerConfig.id)

			if (!layerInstance) throw new Error(`layer (id: ${layerConfig.id}) not found.`)

			const affectedProps = {}
			// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
			Object.entries(layerConfig.dataProps!).forEach(([propKey, dataStubID]) => {
				if (dataStubID === id) {
					affectedProps[propKey] = value
				}
			})

			// @todo check mutability (rebuild layer if not mutable)
			layerInstance.layer.setProps(affectedProps)
		}
	}

	recreateLayer(id: string) {
		const config = this.configManager.getConfig()
		const layerConfig = config.layers.find((l) => l.id === id)

		if (!layerConfig) throw new Error(`layer (id: ${id}) not found.`)

		// create a new instance of this layer
		const initialProps = getInitialProps(layerConfig, config.dataStubs)
		const newLayerInstance = createLayer(LayerClasses, layerConfig.class, initialProps)

		// replace the old one
		const layer = this.layers.find((l) => l.id === layerConfig.id)
		if (!layer) throw new Error('layer not found')

		this.mainStage.removeLayer(layer.id)
		layer.layer.dispose() // NOTE: this is usually empty, but some layers may have custom dispose logic

		layer.layer = newLayerInstance
		this.mainStage.addLayer(layer.id, newLayerInstance, layer.name)
	}

	/**
	 * dispose polaris and all layers and re-create them
	 * - used when config has breaking changes
	 */
	recreatePolaris() {
		// @todo
	}

	getLayerConfigById(id: string) {
		const config = this.configManager.getConfig()
		return config.layers.find((l) => l.id === id)
	}

	// global stats
	static {}

	static $getMeta(): AppMeta {
		return {
			layers: { ...LayerClasses },
		}
	}
}

/**
 * Create a layer instance by class name and constructor props
 */
function createLayer<
	TLayerClasses extends LayerClassesShape,
	TClassName extends keyof TLayerClasses
>(
	classes: TLayerClasses,
	className: TClassName,
	props: Parameters<TLayerClasses[TClassName]['factory']>[0]
): ReturnType<TLayerClasses[TClassName]['factory']> {
	const factory = classes[className]?.factory as TLayerClasses[TClassName]['factory']
	if (!factory) throw new Error(`Cannot find layer type: ${String(className)}.`)

	return factory(props as any) as ReturnType<TLayerClasses[TClassName]['factory']>
}

function findLayerIDsRelatedToDataStub(layersConfig: LayerConfig[], id: string) {
	return layersConfig
		.filter((l) => l.dataProps && Object.values(l.dataProps).includes(id))
		.map((l) => l.id)
}

function getInitialProps(layerConfig: LayerConfig, dataStubs?: DataStub[]) {
	const initialProps = { ...layerConfig.props }

	if (layerConfig.dataProps) {
		Object.entries(layerConfig.dataProps).forEach(([propKey, dataStubID]) => {
			const dataStub = dataStubs?.find((stub) => stub.id === dataStubID)

			if (!dataStub)
				throw new Error(`dataStub (${dataStubID}) required by layer (${layerConfig.id}) not found.`)

			if (initialProps[propKey] !== undefined)
				throw new Error(`prop and dataProp can't have the same key (${propKey}).`)

			if (dataStub.initialValue !== undefined) {
				initialProps[propKey] = dataStub.initialValue
			}
		})
	}

	return initialProps
}

function layerShouldRecreate<
	TLayerClasses extends LayerClassesShape,
	TClassName extends keyof TLayerClasses
>(classes: TLayerClasses, className: TClassName, changedKeys: string[]): boolean {
	const layerClass = classes[className]
	if (!layerClass) throw new Error(`Cannot find layer type:  ${String(className)}.`)

	const { propsDescription } = layerClass

	const immutableKeys = propsDescription.filter((p) => !p.mutable).map((p) => p.key)

	return changedKeys.some((key) => immutableKeys.includes(key))
}
