

uniform sampler2D tex;
uniform sampler2D normalBuffer;
uniform sampler2D depthBuffer;

uniform vec2 resolution;
uniform float blurSize;
// uniform float glossiness;
uniform float gaussianKernel[5];

uniform float cameraNear;
uniform float cameraFar;

float getViewZ(const in float depth) {
	return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
}

in vec2 vUv;

// // TODO 这个为何效果不好
// // https://software.intel.com/en-us/blogs/2014/07/15/an-investigation-of-fast-real-time-gpu-based-image-blur-algorithms
// // automatically generated by GenerateGaussFunctionCode in GaussianBlur.h   
// vec4 GaussianBlur( sampler2D tex0, vec2 centreUV )
// {  
//     // vec2 pixelOffset = 1.0 / resolution;
//     #ifdef DIRECTION_X
//         vec2 pixelOffset = vec2(1.0 / resolution.x, 0.0);
//     #else
//         vec2 pixelOffset = vec2(0.0, 1.0 / resolution.y);
//     #endif

//     vec4 colOut = vec4(0.0);

//     // Kernel width 7 x 7
//     #define stepCount 2
//     const float gWeights[stepCount] = float[stepCount]( 0.44908, 0.05092 );
//     const float gOffsets[stepCount] = float[stepCount]( 0.53805, 2.06278 );


//     for( int i = 0; i < stepCount; i++ )                                                                                                                             
//     {                                                                                                                                                                
//         vec2 texCoordOffset = gOffsets[i] * pixelOffset;                                                                                                           
//         vec4 col = texture2D( tex0, centreUV + texCoordOffset ) + texture2D( tex0, centreUV - texCoordOffset );                                                
//         colOut += gWeights[i] * col;                                                                                                                               
//     }             

//     return colOut;
// }


void main() {
    vec3 centerNormal = unpackRGBToNormal(texture2D(normalBuffer, vUv).rgb);
    float centerDepth = texture2D(depthBuffer, vUv).r;
    float centerZ = getViewZ(centerDepth);

    vec4 color = vec4(0.0);
    float weightAll = 0.0;

    for (int i = 0; i < 5; i++) {
        float fi = float(i);

        // double pass高斯模糊
        #ifdef DIRECTION_X
            float x = (fi - 2.0) * blurSize / resolution.x;
            vec2 coord = vec2(vUv.x + x, vUv.y);
        #else
            float y = (fi - 2.0) * blurSize / resolution.y;
            vec2 coord = vec2(vUv.x, vUv.y + y);
        #endif

        // vec2 coord = vec2(clamp(vUv.x + (float(i) - 6.0) * off, 0.0, 1.0), vUv.y);
        float sampleDepth = texture2D(depthBuffer, coord).r;
        float sampleZ = getViewZ(sampleDepth);

        // Bilateral with 2 domain intensity
        // 只使用深度作为 domain intensity 会导致拐角模糊
        // 只使用normal会导致平行面边缘模糊
        // 对于建筑和地图来说，这两种情况都十分常见
        float w = gaussianKernel[i] * 
            smoothstep(5.0, 3.0, abs(sampleZ - centerZ)) *
            clamp(dot(centerNormal, unpackRGBToNormal(texture2D(normalBuffer, coord).rgb)), 0.0, 1.0);
        weightAll += w;

        color += texture2D(tex, coord) * w;
    }

    gl_FragColor = color / weightAll;
}
