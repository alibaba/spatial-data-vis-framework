# Polaris App 核心概念

Polaris App 是使用 [Polaris.gl 分层空间可视化框架](https://github.com/alibaba/spatial-data-vis-framework) 的最佳实践，它提供了一套简单直白的应用结构、脚手架、模版代码和工具集，来降低 Polaris 的使用难度和维护成本。

## 核心概念

### Layer

Layer 是 PolarisGL 框架的核心概念，代表一个**可复用的功能单元**，通常包括视觉元素、交互行为或存粹的功能逻辑。

所有 Layer 继承 Layer 基类 :

> **继承关系**
>
> [应用 Layer](../src/layers/) -> [StandardLayer](https://github.com/alibaba/spatial-data-vis-framework/blob/dev/packages/core/gsi/src/layer/StandardLayer.ts) -> [AbstractLayer](https://github.com/alibaba/spatial-data-vis-framework/blob/dev/packages/core/base/src/Layer.ts) -> [Node](https://github.com/alibaba/spatial-data-vis-framework/blob/dev/packages/core/base/src/Node.ts) -> [EventDispatcher](https://github.com/alibaba/spatial-data-vis-framework/blob/dev/packages/core/base/src/EventDispatcher.ts)

多个 Layer 实例添加到 Polaris 实例（Layer 树的根）上，即得到一个包含特定功能的可视化应用。

在 [`src/layers`](../src/layers/)中实现你需要的所有 Layer 类（或工厂函数），然后通过配置在运行时创建 Layer 实例。

> 概念对应 ue 中的 actor

### Stage （舞台）

一个 Stage 是一个空 Layer，作为容器，包含和管理用户创建的 Layer 实例。

> 概念对应 ue 中的 level 或 map

> PolarisGL 允许 Layer 组合成树状结构，父子节点之间存在 `生命周期/可见性/投影定位` 的继承关系。
>
> 作为简化，Polaris App 规定 stage 作为容器 layer，应用 layer 则只有一层，扁平地挂在 stage 下。
>
> ```
> PolarisApp 应用实例
>  └─ polaris 实例，作为 Layer 树的根节点，包含具体的渲染器、控制器等
>       ├── mainStage 容器layer，用于批量管理一组 layer 的生命周期、地理投影
>       │     ├── layer 作为功能单元的layer实例
>       │     ├── layer
>       │     └── layer
>       └── otherStages
> ```
>
> 在编码实现 Layer 类的时候依然可以创建子树，作为内部结构，但这些结构对 PolarisApp 不可见。

> ⚠️ 当前版本支持唯一的 MainStage 作为默认 Stage，包含所有 layer 实例。

### Scene （场景）

一个可视化应用包含多个场景，并可以动态切换。这里的`场景`并不是空间区域或容器，而是指应用的不同状态。

每个场景控制：

-   显示哪个 stage （目前只有 main stage）
-   显示这个 stage 中的哪些 layer
-   使用什么相机机位

### DataStub 数据源

PolarisApp 使用 `“数据插槽” (DataStub)` 的概念来接入数据，将数据的提供和使用完全分离。

-   Layer 开发者不关心数据的来源，只将关心自己的 prop (参数)，可监听 prop 的变化并作相应，也可什么都不做，让 PolarisApp 自动重建 Layer 实例来响应变化。
-   在 PolarisApp 的配置 json 中，定义数据插槽，并关联到具体的 layer prop 上。
-   PolarisApp 的使用者则只需要关心为每个数据源传入数据，不关心其用途。

## 开发工作流

我们将应用开发分成 “编码” 与 “搭建” 两个阶段：

-   **编码阶段**：发具体的 `layer 类`，并将所有可能用到的 Layer 类、渲染器、依赖等，打包到一个 `Polaris App 类` 中。
-   **搭建阶段**：编辑 App 的 json 配置，声明式地描述 要创建哪些 layer、参数、样式、场景编排、数据接入、外部交互等。

**编码阶段**由**编程人员**在桌面环境中使用 vscode 开发，使用脚手架中提供的工具链完成打包。

**搭建阶段**在“所见即所得”的 Web 环境中完成，由于配置是声明式的 json 数据，并且可以动态修改，如果使用 gui 编辑器，则可以由设计师或者终端用户完成。`搭建阶段`也可以集成到下游平台中进行，相当于二次开发或二次搭建。

两者之间往往需要一个 **发布操作** 来将编码阶段的产物`提供`到搭建阶段的环境中。可以通过 CDN、npm 包或者本地服务、云服务。

## 高级概念

### 事件

Polaris App 实例使用事件总线来分发和监听所有内部事件，可以添加监听器来管控 app 的运行，也可以发送/监听自定义事件，来实现高度定制的内外联动、复杂交互、layer 间通信等。

出于安全考虑，应用开发者不应直接使用事件总线的实例，而应通过 `app.getEventBusAgent()` 方法获取一个事件总线的代理入口。

详见：

-   [顶层 API #事件系统](./顶层API.md#事件系统)
-   [事件格式与事件列表](../src/private/event/events.ts)
-   [EventBusAgent 接口](../src/private/event/bus.ts)

### 脚本

Polaris App 提供`基于事件的脚本系统`，通过配置来实现复杂的定制功能，而不用修改 Layer 类、无需编译打包。脚本系统设计目的是为配置和搭建环节提供低代码扩展能力。

`脚本`本质上是 **挂载到特定对象上的事件监听器**，目前支持挂载 layer/stage/app 实例，被总线事件触发后，在每个所挂载的对象上执行一次。

#### handler 运行上下文

脚本所监听的事件触发后，handler 代码会被包装为一个 `top level Function 对象` 调用执行。

执行上下文中会提供触发该次执行的 `event` 对象，类型参见 [Event 接口](../src//private/event/events.ts)，其中：

-   `event.currentTarget` 是脚本所挂载的实例
    -   若挂载多个实例，则在每个实例上分别执行脚本
    -   `scriptInit 事件` 触发时挂载对象可能还未创建，currentTarget 为 null
-   `event.target` 是发出事件的对象
    -   对于`内置事件`来说，该值总是当前的 PolarisApp 实例
    -   对于`自定义事件`来说，该值是事件发送方调用 `getBusAgent` 时提供的对象
    -   对于`scriptInit 事件`来说，该值为 null

> 💡 与 DOM Event 接口的异同:
>
> -   `currentTarget` 和 `target` 的含义与区别与 [DOM 事件](https://stackoverflow.com/questions/10086427/what-is-the-exact-difference-between-currenttarget-property-and-target-property)一样
> -   造成 `currentTarget !== target` 的原因不同
>     -   `DOM Event`会冒泡，父元素上的监听器可以收到到子元素上触发的事件，`currentTarget`是`target`的父级
>     -   PolarisApp 的 `BusEvent` 是全局广播的，所有监听者能收到所有事件，因此`currentTarget`和`target`没有上下级关系

> ⚠️ 暂时没有提供`全局变量`或`外部依赖注入`机制，如果自行解决，请关注后续升级的兼容性。

> 💡 事件`发出者`在`申请busAgent` 时，应提供合理的对象，来向`接收者`表明自己的身份。

#### targets 挂载目标

如果一个脚本的任务是操作一个或多个 layer 实例，则应该明确挂载到这些 `layer 实例` 上，触发后通过 `event.currentTarget` 获取这些 layer。

如果一个脚本不操作具体的 layer，则可以挂载到 `app` 上。

> ⚠️ 脚本编写者应注意 handler 副作用的范围。PolarisApp 在配置变化后会自动重建受影响的 Layer 并重新挂载脚本，如果脚本对 target 以外的内容进行操作，PolarisApp 将无法保证正确响应配置变化，可能需要重载应用才能得到正确结果。

#### 参考

-   [《脚本案例》](./script_examples.js)
-   [《脚本配置的格式》](../src/private/schema/scripts.ts)
