# Polaris App 核心概念

Polaris App 是使用 [Polaris.gl 分层空间可视化框架](https://github.com/alibaba/spatial-data-vis-framework) 的最佳实践，它提供了一套简单直白的应用结构、脚手架、模版代码和工具集，来降低 Polaris 的使用难度和维护成本。

## 核心概念

### Layer

Layer 是 Polaris.gl 框架的核心概念，代表一个**可复用的功能单元**，通常包括视觉元素、交互行为或存粹的功能逻辑。

所有 Layer 继承 Layer 基类 :

> **继承关系**
>
> [应用 Layer](../src/layers/) -> [StandardLayer](https://github.com/alibaba/spatial-data-vis-framework/blob/dev/packages/core/gsi/src/layer/StandardLayer.ts) -> [AbstractLayer](https://github.com/alibaba/spatial-data-vis-framework/blob/dev/packages/core/base/src/Layer.ts) -> [Node](https://github.com/alibaba/spatial-data-vis-framework/blob/dev/packages/core/base/src/Node.ts) -> [EventDispatcher](https://github.com/alibaba/spatial-data-vis-framework/blob/dev/packages/core/base/src/EventDispatcher.ts)

多个 Layer 实例添加到 Polaris 实例（Layer 树的根）上，即得到一个包含特定功能的可视化应用。

在 [`src/layers`](../src/layers/)中实现你需要的所有 Layer 类（或工厂函数），然后通过配置在运行时创建 Layer 实例。

> 概念对应 ue 中的 actor

### Stage （舞台）

一个 Stage 是一个空 Layer，作为容器，包含和管理用户创建的 Layer 实例。

> 概念对应 ue 中的 level 或 map

> Polaris.gl 允许 Layer 组合成树状结构，父子节点之间存在生命周期、可见性和投影定位的继承关系。
>
> 作为简化，Polaris App 规定 stage 作为容器 layer，应用 layer 则扁平地挂在 stage 下。
>
> ```
> PolarisApp 应用实例
>  └─ polaris 实例，作为 Layer 树的根节点，包含具体的渲染器、控制器等
>       ├── mainStage 容器layer，用于批量管理一组 layer 的生命周期、地理投影
>       │     ├── layer 作为功能单元的layer实例
>       │     ├── layer
>       │     └── layer
>       └── otherStages
> ```
>
> 在编码实现 Layer 类的时候依然可以创建子树，作为内部结构，但这些结构对 PolarisApp 不可见。

> ⚠️ 当前版本支持唯一的 MainStage 作为默认 Stage，包含所有 layer 实例。

### Scene （场景）

一个可视化应用包含多个场景，并可以动态切换。这里的`场景`并不是空间区域或容器，而是指应用的不同状态。

每个场景控制：

-   显示哪个 stage （目前只有 main stage）
-   显示这个 stage 中的哪些 layer
-   使用什么相机机位

### DataStub 数据源

PolarisApp 使用 `“数据插槽” (DataStub)` 的概念来接入数据，将数据的提供和使用完全分离。

-   Layer 开发者不关心数据的来源，只将关心自己的 prop (参数)，可监听 prop 的变化并作相应，也可什么都不做，让 PolarisApp 自动重建 Layer 实例来响应变化。
-   在 PolarisApp 的配置 json 中，定义数据插槽，并关联到具体的 layer prop 上。
-   PolarisApp 的使用者则只需要关心为每个数据源传入数据，不关心其用途。

## 开发工作流

我们将应用开发分成 “编码” 与 “搭建” 两个阶段：

-   **编码阶段**：发具体的 layer 类，并将所有用到的 Layer 类、渲染器、依赖等，打包成一个 Polaris App 类中。
-   **搭建阶段**：编辑 App 的 json 配置，声明式地描述 layer 的参数、样式、场景编排、数据接入、外部交互等。

**编码阶段**由**编程人员**在桌面环境中使用 vscode 开发，使用脚手架中提供的工具完成打包。

**搭建阶段**在“所见即所得”的 Web 环境中完成，由于配置是声明式的 json 数据，并且可以动态修改，如果使用 gui 编辑器，则可以由设计师或者终端用户完成。

**搭建阶段** 也可以由下游平台进行，相当于二次开发或二次搭建。

两者之间往往需要一个 **发布操作** 来将编码阶段的产物发布到搭建阶段的环境中。可以通过 CDN、npm 包或者专用服务。

## 高级概念

### 事件

Polaris App 实例使用事件总线来分发和监听所有内部事件，可以添加监听器来管控 app 的运行，也可以发送/监听自定义事件，来实现高度定制的内外联动、复杂交互、layer 间通信等。

出于安全考虑，应用开发者不应直接使用事件总线的实例，而应通过 `app.getEventBus()` 方法获取一个事件总线的代理入口。在脚本中，可以通过 `event.getEventBus()` 获取代理。

详见：

-   [顶层 API #事件系统](./顶层API.md#事件系统)
-   [事件格式与事件列表](../src/private/event/events.ts)
-   [EventBusAgent 接口](../src/private/event/bus.ts)

### 脚本

Polaris App 提供`基于事件的脚本系统`，通过配置来实现复杂的定制功能，而不用编写 Layer 代码，无需编译打包。脚本系统设计目的是为配置和搭建环节提供低代码扩展能力。

脚本本质上是 **挂载到特定实例上的事件监听器**（目前支持 layer/stage/app 实例），脚本被总线事件触发执行。

##### handler 运行上下文

脚本所监听的事件触发后，handler 代码会被包装为一个 top level function 调用执行。

上下文中会提供触发该次执行的 `event` 对象，类型参见 [EventBase](../src//private/event/events.ts)，其中：

-   `event.target` 是触发脚本的对象
    -   对于`内置全局事件`来说，该值总是 PolarisApp 实例
    -   对于`自定义事件`来说，该值是事件发送方调用 `getBusAgent` 时提供的对象
    -   对于 `scriptInit 事件` 来说，该值为 null
-   `event.currentTarget` 是脚本所挂载的实例

> ⚠️ 暂时没有提供全局变量或外部依赖的注入机制，如果自行解决，请关注后续升级的兼容性。

##### 挂载点

如果一个脚本的任务是操作一个 layer 实例，则应该挂载到这个 `layer 实例` 上，运行时通过 `event.currentTarget` 获取并操作这个 layer。

如果一个脚本不操作具体的 layer，则可以挂载到 `app` 上。

> ⚠️ 脚本编写者应注意脚本副作用的范围，如果对 target 以外的对象进行修改，Polaris App 将无法正确响应配置变化。

##### 参考

-   [《脚本案例》](./script_examples.js)
-   [《脚本定义格式》](../src/private/schema/scripts.ts)
